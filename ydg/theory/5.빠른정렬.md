# 빠른정렬

Quick Sort는 `피벗(Pivot)`을 이용한다. 피벗을 기준으로 작은 값들과 큰 값들로 나눠 정렬하기 때문에 피벗을 어떻게 정하느냐에 따라서 정렬의 속도가 달라진다. 

**분할정복법**

+ 분할 : 배열을 다음과 같은 조건이 만족되도록 두 부분으로 나눈다.
  피벗보다 작은 원소들 <= 피벗보다 큰 원소들
+ 정복 : 각 부분을 순환적으로 정렬
+ 합병 : Do Nothing ---> 앞, 뒤가 정렬되어있기 때문에 전체로 봤을 때 이미 정렬이 되어있음.



**예**

1. 정렬할 배열이 주어지면, 마지막 수를 피벗으로 정함
2. 기준보다 작은 수는 기준의 왼쪽에, 나머지는 오른쪽에 오도록 **분할**  = `Partition`
3. 기준의 왼, 오른쪽을 각각 순환적으로 정렬



**sudo code**

```java
quickSort(A[], p, r){              //A[p...r]을 정렬
    if(p<r){
        q = partition(A, p, r);    //분할
        quickSort(A, p, q-1);      //왼쪽 부분배열 정렬
        quickSort(A, p+1, q);      //오른쪽 부분배열 정렬
    }
}
partition(A[], p, r){
    배열 A[p...r]의 원소들을 A[r]을 기준으로 양쪽으로 재배치하고 
    A[r](=pivot)이 자리한 위치를 return 한다.
}
```



**partition 함수 해석**

> p : 시작
>
>  i : 피벗보다 작은 원소 중 마지막 원소
>
>  j : 지금 비교하려는 요소
>
>  r : 피벗
>
> ( p< i < j< r)

A[p...i] (피벗보다 작은 원소들) 와 A[i+1...j-1] (피벗보다 큰 원소들)로 나뉘어져 있고, A[j]를 피벗과 비교한다고 했을 때 아래 두 가지 케이스를 생각할 수 있다.

1. A[j] >= A[r]
2. A[j] < A[r]

(1)은 피벗보다 크기 때문에 현재 위치에 그대로 있으면 된다. (2)는 피벗보다 작을 원소이니 SWAP(A[i+1] , A[j])를 해주면 왼쪽에는 피벗보다 작은 원소들, 오른쪽에는 큰 원소들이 모이게 된다.

```java
if(A[j]>= A[r]) j+=1; //오른쪽은 이미 큰 원소들로 되어있기 때문에 다음을 비교하기 위해 1증가
else{
    i+=1;               //i까지가 피벗보다 작은 원소들이니 i+1로 움직이고
    SWAP(A[i+1], A[j]); //i+1원소와 현재 비교환 j원소를 바꿔준다.
    j+=1;               //다음 원소를 위해 1증가
}     
```



**Func partition90 sudo code**

```java
partition(A, p, r){
    X = A[r];
    i = P-1;
    for j=p to r-1                 
        if A[j] <= x {             //작을때만 고려
            i+=1;                  //i(피벗보다 작은 원소들 중 가장 큰 원소의 위치)
            SWAP(A[i], A[j]);
        }
    SWAP(A[i+1], A[r]);            //피벗이 들어갈 위치
    //피벗보다 큰 원소들 중 첫번째 원소 = 피벗보다 작은 원소들 중 가장 큰 원소(i) +1
    return i+1;
}
```



**QuickSort 시간복잡도**

(강의 참고)

1. 최악의 경우

   + 항상 한 쪽은 0개, 다른 쪽은 n-1개로 분할되는 경우

   + 이미 정렬된 입력 데이터(마지막 원소를 피벗)

     = O(n^2)

2. 최선의 경우

   + 피벗이 중간값일 때 
     =O(nlogn)

*** Partition의 시간복잡도 : O(n) 



**Pivot 선택의 기준**

+ 첫번째 or 마지막 값
  + 이미 정렬되어있거나 거꾸로 정렬된 데이터 = 최악
  + 현실의 데이터는 랜덤하지 않으므로 정렬(거꾸로)된 데이터가 입력으로 들어올 가능성은 높음
  + 좋은 방법 X
+ 중간 값  ---> 이걸로 ㄱㄱ
  + 첫번째, 마지막, 가운데 값 중 중간값 선택
  + 최악의 경우 시간복잡도가 달라지지 않음
+ 랜덤
  + 어떤 입력이 들어오더라도 랜덤하게 선택하니 최악의 경우는 고려할 수 없음
  + 극단적인 상황에서 최악의 경우만 뽑았을 때가 최악의 경우
  + 평균 시간복잡도 O(nlogn)





