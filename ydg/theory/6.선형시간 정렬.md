# 선형시간 정렬

## Counting Sort

n개의 정수를 정렬하라. 단 모든 정수는 0에서 k사이의 정수이다. 
예) n명의 학생들의 시험점수를 정렬하라. 단, 모든 점수는 100이하의 양의 정수이다.

### Example

K=5일때, 2 5 3 0 2 3 0 3 을 Counting Sort.

n 0 1 2 3 4 5

   2 0 2 3 0 1  >>>  n이 나온 횟수

```java
int A[n];
int C[K] = {0,};
for(int i=1; i<=n; i++) C[A[i]]++;
for(int s=1, i=0; i<=k; i++)
    for(int j=0; j<c[i]; j++) A[s++] = i;
```



위의 코드는 괜찮을까?

일반적으로 정렬을 할 때, 정렬할 값을 정수라고 제한을 뒀지만 실제로는 그렇지 못할 때가 훨씬 많다. (이름-전화번호-주소 등을 정렬).즉, 대부분의 경우 정렬할 key 값들은 레코드의 일부이기 때문!



### Example - 변형

K=5일때, 2 5 3 0 2 3 0 3 을 Counting Sort.

1. n 0 1 2 3 4 5
      2 0 2 3 0 1 
2. 누적합 구하기 
      2 2 4 7 7 8
3. 정렬하려는 배열의 맨 뒤부터 자리파악 하여 넣기
   + 누적합이 의미하는 것은 그 자리를 보장한다는 것.
     예를 들어 맨 마지막 3은 누적합을 봤을 때 3보다 같거나 작은것이 7개 있다는 의미. 따라서 정렬할 곳 7번째에 두면 안전하다는 의미이다.
4. 해당 위치에 두면 누적합에서 -1 
   + 위에서 3을 놨으니 누적합에서 3의 7을 하나 줄여 6으로 할당

**sudo code**

```java
Counting_sort(A,B,k){
    for i 0 to k                    //C를 초기화
        do C[i] <- 0;                
    for j 1 to length[A]            //Counting
        do C[A[j]] <- C[A[j]]+1;
    for i 1 to k                    //누적합
        do C[i] <- C[i] + C[i-1];
    for j <- length[A] downto 1     //맨 뒤부터 자리찾기
        do B[C[A[j]]] <- A[j]
            C[A[j]] <- C[A[j]]-1;   //count값 1 감소
}
```





